import asyncio
from contextlib import contextmanager
from math import isclose
from pathlib import Path
from zoneinfo import TZPATH

import orjson
from shapely.geometry import shape
from zstandard import ZstdDecompressor

from app.utils import HTTP


@contextmanager
def open_zone_tab():
    for tz_path in map(Path, TZPATH):
        for filename in ('zone1970.tab', 'zone.tab'):
            try:
                with tz_path.joinpath(filename).open() as f:
                    yield f
                    return
            except OSError:
                pass

    raise FileNotFoundError('zone.tab not found in TZPATH')


def get_timezone_country_dict() -> dict[str, list[str]]:
    result = {}
    print('Processing country timezones')

    with open_zone_tab() as f:
        for line in f:
            line = line.strip()
            if not line or line[0] == '#':
                continue

            parts = line.split('\t', 3)
            if len(parts) < 3:
                raise ValueError(f'Unexpected zone.tab format: {line!r}')

            countries = parts[0].split(',')
            timezone = parts[2]

            assert timezone not in result, f'Duplicate timezone {timezone!r}'
            result[timezone] = countries

    return result


async def get_country_bbox_dict() -> dict[str, tuple[float, float, float, float]]:
    print('Downloading country data')
    r = await HTTP.get(
        'https://osm-countries-geojson.monicz.dev/osm-countries-0-1.geojson.zst'
    )
    r.raise_for_status()

    content = ZstdDecompressor().decompress(r.content)
    features = orjson.loads(content)['features']
    result = {}

    print('Processing country boundaries')
    for feature in features:
        tags: dict[str, str] = feature['properties']['tags']
        country = tags.get('ISO3166-1:alpha2', tags.get('ISO3166-1'))
        if country is None:
            raise ValueError(f'Country code not found in {tags!r}')

        bbox = shape(feature['geometry']).bounds

        if country == 'FJ':
            bbox = (-182.870666, -20.67597, 181.575562, -12.480111)
        elif country == 'RU':
            bbox = (19.25, 41.188862, 190.95, 81.857361)
        elif country == 'TV':
            bbox = (176.064865, -10.801169, 179.863281, -5.641972)
        elif country == 'US':
            bbox = (-124.733253, 24.544245, -66.954811, 49.388611)

        if isclose(bbox[0], -180) and isclose(bbox[2], 180):
            print(f'[⚠️] {country}: spanning over 180° meridian')

        if country in result:
            raise ValueError(f'Duplicate country code {country!r}')

        result[country] = bbox

    return result


def generate_typescript_file(data: dict[str, tuple[float, float, float, float]]) -> str:
    print('Generating TypeScript file')

    lines: list[str] = []
    for timezone, bbox in sorted(data.items()):
        lines.append(
            f'    ["{timezone}", [{bbox[0]}, {bbox[1]}, {bbox[2]}, {bbox[3]}]]'
        )

    header = '// This file is auto-generated by `timezone-bbox-update`'
    return (
        f'{header}\n\nexport const timezoneBoundsMap = new Map<string, [number, number, number, number]>([\n'
        + ',\n'.join(lines)
        + ',\n])\n'
    )


async def main() -> None:
    country_bbox = await get_country_bbox_dict()
    timezone_country = get_timezone_country_dict()
    result = {}

    print('Merging timezones with boundaries')
    for timezone, countries in timezone_country.items():
        bboxes = [
            bbox
            for country in countries
            if (bbox := country_bbox.get(country)) is not None
        ]

        if not bboxes:
            print(f'[❔] {timezone}: missing {countries} boundary')
            continue

        result[timezone] = (
            min(b[0] for b in bboxes),
            min(b[1] for b in bboxes),
            max(b[2] for b in bboxes),
            max(b[3] for b in bboxes),
        )

    output = generate_typescript_file(result)
    output_path = Path('app/views/lib/timezone-bbox.ts')
    output_path.write_text(output)


if __name__ == '__main__':
    asyncio.run(main())
